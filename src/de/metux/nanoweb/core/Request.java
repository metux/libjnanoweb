package de.metux.nanoweb.core;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.Properties;

/**
 * Generic web request object
 *
 * Usually generated by an httpd or request multiplexer
 * and passed to an request handler
 */

public class Request implements IRequest {

	/** request data **/
	public Properties headers = new Properties();
	public Properties attributes = new Properties();

	/** IO channels **/
	public BufferedReader reader;
	public OutputStream output;

	/** response data **/
	private int reply_status_code = IRequest.status_ok;
	private String reply_status_str = "";
	private StringBuffer reply_headers = new StringBuffer();
	private boolean reply_header_sent = false;

	/**
	 * constructor
	 */
	public Request(BufferedReader r, OutputStream out) {
		reader = r;
		output = out;
	}

	/**
	 * retrieve a full URI of the (original) request
	 *
	 * @interface IRequest
	 */
	public String getURI() {
		return attributes.getProperty(IRequest.attribute_uri);
	}

	/**
	 * retrieve the requested virtual hostname of the request
	 *
	 * @interface IRequest
	 */
	public String getVirtualHost() {
		return headers.getProperty(IRequest.header_virtual_host);
	}

	/**
	 * retrieve the translated request path
	 *
	 * note: request multiplexers may change this for mounting
	 *       thefore request handlers should look at this value
	 *       instead of the original path
	 */
	public String getPath() {
		return attributes.getProperty(IRequest.attribute_path);
	}

	/**
	 * retrieve the (publically visible) URL root (for mounting)
	 *
	 * @interface IRequest
	 */
	public String getRoot() {
		String r = attributes.getProperty(IRequest.attribute_root);
		if ((r==null) || r.equals(""))
			return "/";
		else
			return r;
	}

	/**
	 * retrieve the protocol identifier string (eg. HTTP/1.0)
	 */
	public String getProtocol() {
		String s = attributes.getProperty(IRequest.attribute_protocol);
		if ((s == null) || (s.equals("")))
			return "HTTP/1.0";
		else
			return s;
	}

	/**
	 * retrieve the request method
	 */
	public String getRequestMethod() {
		String s = attributes.getProperty(IRequest.attribute_method);
		return ((s==null) ? "" : s);
	}

	/**
	 * retrieve request headers as property list
	 */
	public Properties getHeaders() {
		return headers;
	}

	/**
	 * retrieve various request metadata (socket addresses, etc)
	 *
	 * @interface IRequest
	 */
	public Properties getAttributes() {
		return attributes;
	}

	/**
	 * retrieve a specific attribute
	 *
	 * @interface IRequest
	 */
	public String getAttribute(String name) {
		return attributes.getProperty(name);
	}

	/**
	 * set a specific request attribute
	 *
	 * @interface IRequest
	 */
	public void setAttribute(String attr, String value) {
		if (attr == null)
			return;

		attributes.setProperty(attr, value);
	}

	/**
	 *
	 * get (parsed) URL parameter list (UTF-8)
	 *
	 * @interface IRequest
	 */
	public Properties getURLParameters()
	throws UnsupportedEncodingException {
		return getURLParameters("UTF-8");
	}

	/**
	 * get (parsed) URL parameter list
	 *
	 * @param enc Encoding
	 * @interface IRequest
	 */
	public Properties getURLParameters(String enc)
	throws UnsupportedEncodingException {
		Properties pr = new Properties();
		String params = getAttribute(IRequest.attribute_query);
		if (StrUtil.isEmpty(params))
			return pr;

		String elem[] = params.split("&");
		for (int x=0; x<elem.length; x++) {
			String s2[] = elem[x].split("=");
			pr.setProperty(
			    URLDecoder.decode(s2[0], enc),
			    URLDecoder.decode(s2[1], enc)
			);
		}
		return pr;
	}

	/**
	 * helper for adding a new header
	 *
	 * @param header	header name, skipping when null is passed
	 * @param value		header value, automatically trimmed, null is converted to ""
	 */
	public void addHeader(String header, String value) {
		if (header == null)
			return;

		headers.setProperty(header.trim(), (value == null) ? "" : value.trim());
	}

	/**
	 * sets http protocol
	 *
	 * @param protocol	protocol identifier string, when null, assume HTTP/1.0
	 */
	public void setProtocol(String protocol) {
		if (protocol == null)
			protocol = "HTTP/1.0";

		setAttribute(IRequest.attribute_protocol, protocol);
	}

	/**
	 * sets http request method - skipping when null given
	 * also checks for valid method names and skips invalid ones

	 * @param method	request method, automatially converted to uppercase
	 * @result		false when failedd (eg. invalid method given)
	 */
	public boolean setMethod(String method) {
		if (method == null)
			return false;

		method = method.toUpperCase();

		if (!(method.equals("GET") || method.equals("POST") ||
		        method.equals("HEAD") || method.equals("PUT") ||
		        method.equals("DELETE") || method.equals("OPTIONS") ||
		        method.equals("CONNECT")))
			return false;

		setAttribute(IRequest.attribute_method, method);
		return true;
	}

	/**
	 * set the request location, splits into path, query and anchor
	 *
	 * @param location	absolute request location (w/ scheme/hostname/etc)
	 */
	public void setLocation(String location) {
		setAttribute(IRequest.attribute_uri, location);

		/* now parse the URI into its parts */
		String s1[] = location.split("#");
		if (s1.length>1)
			setAttribute(IRequest.attribute_anchor, s1[1]);

		String s2[] = s1[0].split("\\?");
		setAttribute(IRequest.attribute_path, s2[0]);
		if (s2.length>1)
			setAttribute(IRequest.attribute_query, s2[1]);
	}

	/**
	 * set reply status / msg
	 *
	 * @param code		(numerical) http response code
	 * @param msg		response message
	 */
	public void replyStatus(int code, String s) {
		reply_status_code = code;
		reply_status_str = s;
	}

	/**
	 * add reply header. multiple headers with same name allowed.
	 *
	 * @param name		header name
	 * @param value		header value
	 */
	public void replyHeader(String name, String value) {
		reply_headers.append(name+": "+value+"\r\n");
	}

	/**
	 * send out response code and all headers, if not already sent yet
	 */
	private void replySendHeader()
	throws IOException {
		if (reply_header_sent)
			return;

		String str = getProtocol()+" "+reply_status_code+" "+reply_status_str+"\r\n";
		output.write(str.getBytes());
		output.write(reply_headers.toString().getBytes());
		str = "\r\n";
		output.write(str.getBytes());

		reply_header_sent = true;
	}

	/**
	 * send binary reply body data. headers are automatically sent if not done yet
	 * larger streams can be sent via multiple calls
	 *
	 * @param data	binary reply data
	 */
	public void replyBody(byte[] data)
	throws IOException {
		replySendHeader();
		output.write(data);
	}

	/**
	 * send binary reply body data
	 *
	 * @param data	binary reply data
	 * @param sz	maximum bytes to be sent
	 */
	public void replyBody(byte[] data, int sz)
	throws IOException {
		replySendHeader();
		output.write(data, 0, sz);
	}

	/**
	 * send text reply body data. headers are automatically sent if not done yet
	 * larger stream can be sent via multiple calls
	 *
	 * @param s	text to be sent
	 */
	public void replyBody(String s)
	throws IOException {
		replyBody(s.getBytes());
	}

	/**
	 * finish http reply. sends reply code and headers if not done yet
	 */
	public void replyFinish()
	throws IOException {
		replySendHeader();
	}
}
